#pragma kernel CSErosion

RWTexture2D<float4> heightMap;
StructuredBuffer<int2> randomIndices;
StructuredBuffer<int2> brushIndices;
StructuredBuffer<float> brushWeights;

int resolution;
int brushLength;
int borderSize;

int maxLifetime;
float inertia;
float sedimentCapacityFactor;
float minSedimentCapacity;
float depositSpeed;
float erodeSpeed;

float evaporateSpeed;
float gravity;
float startSpeed;
float startWater;

float3 CalculateHeightAndGradient(float posX, float posY)
{
	int coordX = (int)posX;
	int coordY = (int)posY;

	float x = posX - coordX;
	float y = posY - coordY;

	int2 nodeIndexNW = int2(coordY, coordX);
	float heightNW = heightMap[nodeIndexNW].r;
	float heightNE = heightMap[nodeIndexNW + int2(0, 1)].r;
	float heightSW = heightMap[nodeIndexNW + int2(1, 0)].r;
	float heightSE = heightMap[nodeIndexNW + int2(1, 1)].r;

	float gradientX = (heightNE - heightNW) * (1 - y) + (heightSE - heightSW) * y;
	float gradientY = (heightSW - heightNW) * (1 - x) + (heightSE - heightNE) * x;

	float height = heightNW * (1 - x) * (1 - y) + heightNE * x * (1 - y) + heightSW * (1 - x) * y + heightSE * x * y;

	return float3(gradientX, gradientY, height);
}

[numthreads(1024, 1, 1)]
void CSErosion(uint3 id : SV_DispatchThreadID)
{
	int2 index = randomIndices[id.x];
	float posX = index.x + 0.5;
	float posY = index.y + 0.5;
	float dirX = 0;
	float dirY = 0;
	float speed = startSpeed;
	float water = startWater;
	float sediment = 0;

	for (int lifetime = 0; lifetime < maxLifetime; lifetime++)
	{
		int nodeX = (int)posX;
		int nodeY = (int)posY;
		int2 dropletIndex = int2(nodeY, nodeX);

		float cellOffsetX = posX - nodeX;
		float cellOffsetY = posY - nodeY;

		float3 heightAndGradient = CalculateHeightAndGradient(posX, posY);

		dirX = (dirX * inertia - heightAndGradient.x * (1 - inertia));
		dirY = (dirY * inertia - heightAndGradient.y * (1 - inertia));

		float len = max(0.01, sqrt(dirX * dirX + dirY * dirY));
		dirX /= len;
		dirY /= len;
		posX += dirX;
		posY += dirY;

		if ((dirX == 0 && dirY == 0) || posX < 0 || posX > resolution - 1 || posY < 0 || posY > resolution - 1)
		{
			break;
		}

		float newHeight = CalculateHeightAndGradient(posX, posY).z;
		float deltaHeight = newHeight - heightAndGradient.z;

		float sedimentCapacity = max(-deltaHeight * speed * water * sedimentCapacityFactor, minSedimentCapacity);

		if (sediment > sedimentCapacity || deltaHeight > 0)
		{
			float amountToDeposit = (deltaHeight > 0) ? min(deltaHeight, sediment) : (sediment - sedimentCapacity) * depositSpeed;
			sediment -= amountToDeposit;

			heightMap[dropletIndex] += float4(amountToDeposit * (1 - cellOffsetX) * (1 - cellOffsetY), 0, 0, 0);
			heightMap[dropletIndex + int2(1, 0)] += float4(amountToDeposit *      cellOffsetX  * (1 - cellOffsetY), 0, 0, 0);
			heightMap[dropletIndex + int2(0, 1)] += float4(amountToDeposit * (1 - cellOffsetX) *      cellOffsetY, 0, 0, 0);
			heightMap[dropletIndex + int2(1, 1)] += float4(amountToDeposit *      cellOffsetX  *      cellOffsetY, 0, 0, 0);
		}
		else
		{
			float amountToErode = min((sedimentCapacity - sediment) * erodeSpeed, -deltaHeight);

			for (int i = 0; i < brushLength; i++)
			{
				int2 erodeIndex = dropletIndex + brushIndices[i];

				float weightedErodeAmount = amountToErode * brushWeights[i];
				float deltaSediment = (heightMap[erodeIndex].r < weightedErodeAmount) ? heightMap[erodeIndex].r : weightedErodeAmount;
				heightMap[erodeIndex] -= float4(deltaSediment, 0, 0, 0);

				sediment += deltaSediment;
			}
		}

		speed = sqrt(max(0, speed * speed + deltaHeight * gravity));
		water *= (1 - evaporateSpeed);
	}
}
